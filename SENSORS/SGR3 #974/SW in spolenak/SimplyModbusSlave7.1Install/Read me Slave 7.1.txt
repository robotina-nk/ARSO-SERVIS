GETTING STARTED WITH SIMPLY MODBUS SLAVE 7.1

***** Context help is also available by pressing Ctrl-H while in the program *****
*****  Ctrl-H will open a window where information is displayed about items as the cursor hovers over them   *****

See the On-line Manual  ........  http:/www.simplymodbus.ca/RTUslavemanual2.htm

The downloaded zip file, SimplyModbusSlave7.1Install.zip,  contains:
	setup.exe   
	setup.ini
	data.cab
	install.msi
	InstMsi.exe
	InstMsiW.exe
	Read me Slave 7.1.txt                  - this file
	Read me for Windows 7.txt        - some additional notes about running on Windows 7

1) Unzip the files into the same folder.

2) Run setup.exe to start the Simply Modbus Slave 7.1 Installation Wizard
    Follow the prompts.  The program will start automatically when the installation is complete.
    Running setup.exe a second time will uninstall the program.

3) If using Windows 7, Activate Windows XP compatibility as shown in the file Read me for Windows 7.txt 

4) From the Start menu, select Programs > Simply Modbus > Simply Modbus Slave 7.1 to start the program.


PROGRAM SUMMARY...

When the program is opened, the circular clock icon indicator spins to show that the program is running. The program monitors the chosen serial port looking for incoming bytes from a modbus master.. All bytes received (and sent) are displayed in the 'Log'. 

The most recent request received is displayed in the indicator labelled "Latest Request received".
A lookup is done to determine if the request has a valid SlaveID, function code, data addresses, valid data if writing and valid error detection bytes (CRC or LRC).

The request must meet the following 2 conditions before a response is generated and sent:
1) The ID in the request (the first byte received) must match the entered Slave ID, or Respond to all IDs must be checked.
   If the ID does not match, the Slave program will ignore the request since it is intended for a different slave.

2) the CRC (if RTU mode) or LRC (if ASCII mode) at the end of the request must be correct

The request must meet the following additional conditions before a response with data is generated and sent:
3) the request must have a function code that matches enabled data in the tables.
   Function code 03 or 04 to read registers with a block of register data set with the same code.
   Function code 06 or 16 to write registers with a block of register data set as read/write.
   Function code 01 or 02 to read coils with a block of coil data set with the same code.
   Function code 05 or 15 to write coils with a block of coil data set as read/write.
   If not, an exception code 01 is generated and sent.
4) The requested registers or coils must exist in an enabled block.  More specifically, the request must be for register or coil addresses with a hex values that match the register number minus offset for one of the enabled tables.  If not, an exception code 02 is generated and sent.
   For example, A request for 0003 addresses starting from 0002 will match a block setup with Registers 40001 to 40008 and offset 40001.  It will reply with data from 40003, 40004 & 40005.  A request for 0007 addresses starting from 0002 will not match the same block,  since it needs registers 40003 through 40009.  Since 40009 does not exist in the block, an exception code 02 would be generated and sent.

5) When receiving function codes that request writing data, the data size and format must be correct.  If not, an exception code 03 is generated and sent.
   For example, A FC16 request to write 0005 16bit addresses must contain 10 data bytes (two per address), otherwise an exception code 03 would be generated and sent.

When a response is generated, it is written to the serial port and the Log. 

On a multi-dropped network (eg. RS485) with multiple slaves, this application will also receive responses from other slaves.
All messages received will be monitored and processed to determine if they are valid requests from a modbus master.


SETUP DETAILS

Controls (inputs) that can be changed by the user are shown in yellow.
Indicators (outputs) that cannot be changed are shown in blue.

- Enter the input information in the controls to match the Slave you wish to emulate.
           Mode:  RTU (forces data bits=8)
                  ASCII (forces databits=7, it can be changed to 8)
           Serial port:  Select the serial port on your PC that is connected to a modbus master (Range = COM1 to COM10)
           port settings: baud rate = The baud rate (bits per second) of the serial connection.  19200, for example
                          data bits = The number of data bits in each byte. 
                                      RTU mode requires 8 data bits.  ASCII mode is usually 7 but may be 8.
                          stop bit = The number of stop bits for each byte sent.  allowable values are 1, 1.5 or  2 
                          parity = The value of the parity bit for each byte sent. none, odd, even, mark or space.
           Slave ID:  The 1st byte in the Request and Response strings
                      The unit address of the Slave device to be emulated. normal range: 1 to 247
                      The program will only respond to requests directed to this Slave ID.
           Respond to all Slave IDs: When this box is checked, the program will respond to requests directed to any Slave ID.


OTHER SETTINGS
           'High byte/Low byte' - when checked, the program will send the data high byte first
           'Low word/High word' - when checked, the program will send the data high word first for 32 bit data types.

           'add random noise' - when checked, the program will apply a random multiplier to the numerical data from the tables 
                                to a maximum of the '%reading' value entered.  
                                This will have the effect of giving slightly different responses to the same repeated request.

***** Context help is available by pressing Ctrl-H while in the program. *****
***** Information is displayed about items as the cursor hovers over them.   *****

- The program then runs by itself.  That is all that is required.


SAVE AND RESTORE CONFIGURATIONS:
  SAVE CFG     Displays a Save As.. Dialog Box to allow saving the current settings to a text file.
               The data file is saved in csv format (comma separated values).
               The file can be edited with a spreadsheet application and reloaded into the program using RESTORE CFG
  RESTORE CFG  Displays a Open File.. Dialog Box to allow selecting a previously saved settings file to load.


DATA LOG:
  SAVE LOG   Displays a Save As.. Dialog Box to allow the log contents to be saved to a text file.
  Clear Log  Empties the log contents.


ABOUT  Displays information about the program including the program version.

Press the Close box 'X' in the top corner to Exit the program.


DATA TABLE SETUP DETAILS

- Press the DATA button to display and change the register and coil tables.
           Blocks 1 to 4 are registers for storing numerical data 
           Blocks 5 to 6 are coils for storing boolean (on/off) data
	   Enabled - Each block can be set to enabled or disabled.
           function code - Each register block is set to respond to either FC03 or FC04 read register requests.
                           Each coil block is set to respond to either FC01 or FC02 read coil requests.
           Write - Each block can be set as read only to accept the only the function code above,
                   or read/write to allow the host to change the data with FC06&16 (for registers) and FC05&15 (for coils)
           Register size - Each register block can be set as 16bit registers (typical for standard modbus), 
                         or 32bit registers (used for Enron modbus 32bit Int (5000) block or 32bit float (7000) block)
           Register Data Type: Selectable as
                                 32bit IEEE Floating Point
                                 32bit Unsigned Integer (0 to 4.3 billion)
                                 32bit Signed Integer   (-2.1 to 2.1 billion)
                                 16bit Unsigned Integer (0 to 65535)
                                 16bit Signed Integer   (-32768 to 32767)
                            Selecting a 32bit Data type with 16 bit register size will use 2 registers for each value.
           First register or coil - Sets the register or coil numbers for the block
           offset - sets the difference between the register number and the hex number used in the commands for each block
                           for example register#40005 minus offset 40001 = hex address 0004)
           number of values - this sets how many registers or coils are in each block
           register or coils - a read-only indicator displaying the register or coil numbers as set above
           hex - a read-only indicator displaying the hexadecimal equivalent of register or coil numbers minus the offset.
           values - this is where the data values are entered.
- Press OK to accept the changes entered or press CANCEL to leave the data unchanged.

PHYSICAL CONNECTION:
To receive requests from a modbus master before sending a message, the serial port needs to be physically connected to a modbus master device. The simplest connection is RS232C on a single serial cable.
DTE masters (PC serial ports) have DB9 male connectors which transmits on pin3, receives pin2 and grounds on pin5. A DCE slave will have a DB9 Female connector which will allow the use of a straight through cable. A DTE slave will have a DB9 Male connector and will require the use of a null modem cable. 

The RS232 specification states a maximum distance of 50 feet at 20kbaud. Slightly longer connections are possible at slower baud rates depending on cable quality and noise in the area.
Modems and radios are used to transmit longer distances. These are typically DCE devices so straight through cables can be used.  Some MDS non-spread spectrum radios require RTS Delay to be used so a 4th conductor is needed on pin 4.
RS485 converters can be used to extend the distance up to 4000 feet at 100kbaud. This can be a 4 wire or 2 wire system, depending on the converter. This also allows multi-dropping up to 32 devices on one pair of wires.

PROGRAM OPERATION:
Once the correct input data is entered, the program operates by itself.

When bytes are read on the serial port, they are displayed in "Latest Request Received"
The bytes are then processed to see if a response should be generated.

The first byte of the request is shown in 'ID'.  This is the Slave Address that the Master is requesting a response from.
The 'Slave ID' entered is converted to hex and displayed in 'search addr'.  If "All" is selected, this will show '00'
If the 'addr' is the same as the 'search addr', the 'addr match' indicator will turn green as shown.



The second byte of the request is shown in 'fc'.  This is the Function code indicating which table to read from.
This program only supports function code 03.
If function code 03 is found in the request, the 'fc03' indicator will turn green as shown.




The 3rd and 4th bytes of the request are shown in '1st'.  This is the register address of first register to read.
This number is converted from hex to decimal, the offset is added and the result displayed in 'First Register'.
The program then scans the 3 tables for this register. The matching table is displayed in 'found in block'.



The 5th and 6th bytes of the request are shown in '#'.  This is the number of registers to read.
This is converted from hex to decimal and displayed in '# of Registers'.




The 7th and 8th bytes of the request are shown in 'CRC' (or 'LRC' if in ASCII mode).  
This expected CRC is calculated from the first 6 bytes and displayed in 'Expected CRC'.
If the two CRCs match, the 'crc ok' indicator will turn green as shown.
crc  The last 2 bytes of a modbus RTU message are the cyclic redundancy check.  These are error detection bytes more info...
lrc  ASCII Mode messages are preceded with a colon and the crc is replaced with an lrc, longitudinal redundancy check, carriage return and line feed characters.  more info... 

If the 'addr match', 'fc 03' and ' crc ok' indicators all turn green, a response will be generated.
The three tables are scanned to find the requested registers.


The information found is shown in this table.
The columns show the register number, its value in decimal and its value in hex.

Add Random Noise
        When this box is checked, the program will modify the values found in the tables
         by a random multiplier plus or minus to the '% reading' value entered.
        The program will then give slightly different responses when the same request is repeated.

The response is then generated and shown in "Latest response given'.




The bytes in the response are parsed as shown here:
   0A              The Slave ID responding
   03              The function code
   06              The number of data bytes to follow
FF FF 00 00 00 01  The data bytes representing the values in the requested registers.
   93 9E           The CRC (or 'LRC' if in ASCII mode).


Troubleshooting
Check the physical connection to make sure the correct conductors are on the correct pins and the correct serial port.
Check the serial settings in the master device to make sure they match the settings in the slave.
Make sure the serial port driver file (serpdrv) is in the same folder as SimplyModbusSlave1.3.2.exe

--- Saved Configuration file ---
The format of the file is csv (comma separated values).
1st column contains descriptions, 2nd column contains values:
Mode             0=ASCII, 1=RTU
COM port         0=COM1, 1=COM2 etc
baud rate
data bits
stop bits        0=1bit, 1=1.5bits, 2=2bits			
parity           0=none , 1=odd, 2=even, 3=mark, 4=space
Address          slave ID
offset
na               not used
Data type1       0=32bit IEEE Floating Point
                 1=32bit Unsigned Integer (0 to 4.3 billion)
                 2=32bit Signed Integer   (-2.1 to 2.1 billion)
                 3=16bit Unsigned Integer (0 to 65535)
                 4=16bit Signed Integer   (-32768 to 32767)
Reg size1        0=1 bit coils, 1=16bit registers, 2=32bit registers
Data type2
Reg size2
Data type3
Reg size3
byte order
word order
scroll lock	0=unchecked, 1=checked
add noise	0=unchecked, 1=checked
%reading	Integer

3rd and 4th columns contains register#s and values for the 1st data block
5th and 6th columns contains register#s and values for the 2nd data block
7th and 8th columns contains register#s and values for the 3rd data block

--------------
SPECIFICATIONS / SUPPORTED FEATURES :
 - RTU and ASCII mode
 - serial ports: COM1 to COM99
 - baud rates: tested to 76800
 - Modbus modes: RTU and ASCII
 - Function codes 01,02,03,04,05,06,15,16 (read and write registers and coils)
 - register addresses from hex 0000 to FFFF (equal to register names from 40001 to 105537 with offset=40001)
 - Data Types: 32bit IEEE Floating Point
               32bit Unsigned Integer (0 to 4.3 billion)
               32bit Signed Integer   (-2.1 to 2.1 billion)
               16bit Unsigned Integer (0 to 65535)
               16bit Signed Integer   (-32768 to 32767)
               1bit Boolean   (0 or 1)
 - High byte/Low byte (big endian) or Low byte/High byte (little endian)
 - Low word/High word (big endian) or Low word/High high (little endian)
 - Register size selection: 16 bit registers or 32 bit registers
 - 4 blocks of numerical data of up to 1000 registers each
 - 2 blocks of boolean data of up to 1000 coils each
 - Saves and Restores settings to/from a csv file
 - displays and the saves communication log to a text file.

--------------
Visit www.simplymodbus.ca for updates and detailed information on how the modbus protocol works.

See www.simplymodbus.ca/RTUslavemanual2.htm for a detailed On-Line Manual.

Send all questions and comments to info@simplymodbus.ca